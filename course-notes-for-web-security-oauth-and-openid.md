---
description: >-
  Course notes for LinkedInLearning course "Web Security: OAuth and OpenID
  Connect
---

# Course Notes for Web Security: OAuth and OpenID

[Course](https://www.linkedin.com/learning/web-security-oauth-and-openid-connect/welcome) Author: Keith Casey

* OAuth 2.0
* OpenID Connect \(OIDC\)

## Resources

* [Okta: API Access Management](https://developer.okta.com)
* [Token Introspection Tool \(www.jsonwebtoken.io\)](https://www.jsonwebtoken.io)
* [Google OAut Playground](https://developers.google.com/oauthplayground/)
* [OpenID Connect Playground](https://openidconnect.net)
* [The PHP League OAuth 2.0 Server](http://oauth2.thephpleague.com) \([Git](https://github.com/thephpleague/oauth2-server), [Git Examples](https://github.com/thephpleague/oauth2-server/tree/master/examples)\)
* [OAuth.com](https://www.oauth.com/): [Map of OAuth Specs](https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs/)
* Book: [OAuth 2.0 Simplified](https://oauth2simplified.com/)

## OAuth 2.0

OAuth is Authorization, **not** Authentication. OAuth specs don't address Authenciation at all \(these are in other specs\). OAuth is a framework that other things can plug into. So, don't need to share credentials \(passwords, etc\).

Analogy: Checking into a hotel.  
1. At front desk, use id \(drivers license or passport\) to verify \(Authenticate\) your identity. 2. They use id and credit card validation to find reservation. 3. Issue you a keycard - provides Authorization. Gives access to room, pool, exercise room, etc. 4. Your personal information never leaves the front desk, only the keycard.

### How it works

Based on OAuth clients and the grant types \(or flows\) they provide. Only provide specific access permissions, not everything. The specific permissions granted are utilized via a token generated by the resource provider. Benefits: 1. Don't give out password 2. Revoke access at any time 3. 3rd party website can only do what we granted

### Vocabulary

* **flow** or **grant type**: the exchange of the token
* **scopes**: the permissions granted by the token \(determined by the resource provider\)
* **token**: the item issued by the resource provider via the flow, which provides access to the resource \(**not** username and password\)
* **Extensions**: additional software that fills in the gaps in OAuth \(such as identity information via OpenID Connect\) - extensions vary from provier to provider and are optional

## OpenID Connect \(OIDC\)

* Extension on top of OAuth 2.0 - designed for identity.
* Defines specific fields \(content and structure\) for sharing profile information, such as address, phone number, email and other fields.
* this is done through an ID token
* not part of the previous OpenID standard  
* OIDC is not for AuthZ, but builds on OAuth \(which is for AuthZ\)
* Only for users \(not, for instance, microservices\)

## Core Terminology - Endpionts

[RFC cheatsheet](https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs/)

### OAuth Endpoints \(defined in spec RFC 6749: OAuth Core\)

* /authorize:

  > Endpoint which the end user \(resource owner\) interacts with to grant permission to the resource for the application Could return an authorization code or an access token

* /token

  > Endpoint which the application uses to trade an authorization code or refresh toekn for an access token

* No other endpoints are defines - everything else is handled by an extension

**Token Revocation \(RFC 7009\)**

* /revoke

  > Endpoint which applications use to deactivate \(invalidate\) a token Valid for access or refresh tokens

**Token Introspection \(RFC 7662\)**

* /introspect

  > Endpoint which applications use to learn more about a token Checks whether token is active or not, taking into consideration the expiration date Optional fields: expiration time, scopes included, issued to client\_id, etc

**Dynamic Client Registration**

* /register

  > Endpoint applications use to create new OAuth clients \(client\_id and client\_secret\) for provisioning new applications or users Introduces concept of "metadata discover documents"

**OpenID Connect Core \(number of different specs included\)**

* /userinfo

  > Endpoint applications use to retrieve profile info for authenticated user Returns a spec-defined set of fields, which depend on the permissions \(scope\) requested

**Server Discovery \(a Working Draft\)**

* /.well-known/openid-configuration

  > Endpoint applications use to retrieve the config information for the OIDC server Returns spec-defined set of fields

## **Tokens**

* Access Token \(OAuth 2.0 Core\)

  > Given by application to access the protected resource on the user or application's behalf No formal requirements to format, contents, etc.

* Refresh Token \(OAuth 2.0 Core\)

  > Used by application to request a new access token on its expiration Useful to enable long term access to resource without needing to issue a long-term access token. Instead, use short-lived access tokens, then force the application to return to the server and exchange the Refresh Token \(checking permissions in the process\)

* ID Token \(OpenID Connect Core\)

  > Specifically designed for user profile information Details the main structures, naming and when to use them.

## **Token Management \(ID Token\)**

> Per Internet Engineering Task Force:
>
> * Access Tokens are credentials used to access protected resources. An access token is a string representing an authorization issued to the client.  The string is usually opaque to the client.
> * Tokens represent specific scopes and durations of access, granted by the resource owner, and enforced by the resource server and authorization server.  
> * The access token provides an abstraction layer, replacing different authorzation constructs \(e.g., username and password\) with a single token understood by the resource server.
> * Access tokens can have different formats, structures, and methods of utilization \(e.g., cryptographic properties\) based on the resource server security requirements.
>
>   **JSON Web Token \(JWT\) RFC 7519**
>
>   Defines the Claims:

* "iss": the issuer of the token, an entity we trust
* "sub": the subject \(user\) of the token
* "aud": the audience or intended recipient of the token \(always check this to verify this token is for you\)
* "exp": expiration time of the token \(for high security situation, short \(few minutes\); for low security, can be weeks or months\)
* Additional fields...

**Token Revocation \(RFC 7009\)**

Note that when a access or refresh token is revoked, there is no requirement for revokation to be broadcast to applications or APIs.  It is up to the application or API to check the revoke status of the token.

## **Scopes and Claims**

Scope:

* What am I allowed to do?
* A group of permissions that a user can grant to an application to take action on their behalf.
* Are completely undefiend in OAuth - it's up to the provider.

  Claim:

* A key/value pair in the token that gives the client application information.
* Again are completly undefiend in OAuth.  

  Efforts to standardize scopes and claims:

* [Heart Working Group](http://openid.net/wg/heart)
* [Financial API](http://openid.net/wg/fapi)

## **Main Flows \(GrantTypes\)**

### Client Credentials Flow \(Grant Type\)

Designed specifically for server-to-server interactions, similar to "service accounts" from Active Directory and other backend services. No user involved \(therefore not compatible with OIDC\).

See [Okta documentation Client Credentials Flow](https://developer.okta.com/authentication-guide/auth-overview/#client-credentials-flow) for information on this flow. See [Implementing the Client Credentials Flow](https://gist.github.com/kozigh01/14b53aee646eafd6480ffb548b422593) for details.

Example: [Client Credential Flow](https://gist.github.com/kozigh01/8728f5c855ad9b4e3f9c9ee08371e34c#file-client-credentials-flow-md): shows example of using Postman to retrieve JWT token.

Main points:

* Always done by backend system, never a user
* The Client Credentials Grant Type is only for 'private' clients where the interaction is handled by backend code
* Uses application client id and client secret \(app username/password\) - not an individual's credentials

Good News:

* No user involved - no user password compromise issues  

Security Considerations:

* Secrets must be kept in backend code - so, not usable for mobile apps or single page apps  
* Must use secure communications - something like TLS  
* No logging / audit information per user, just at the application level  
* Make sure to validate access token \(possible use /introspect endpoint if available \(or use RFC 7519 token validation rules\)  
* Make sure to handle expiration correctly  

### Implict or Hybrid Flow - Authorization for Mobile Devices \(Web Apps, Native\)

This flow is designed specifically for untrusted or 'public' clients, where a malicius user could get access to the source code. For scenerios here we can't count on our client\_secret staying safe. This is only for users who explicitly grant authorization via an authentication and user-consent flow.

See Okto documentation [Implicit Flow](https://developer.okta.com/authentication-guide/auth-overview/#implicit-flow) for a diagram of this flow. See [Implementing the Implicit Flow](https://developer.okta.com/authentication-guide/implementing-authentication/implicit) for details.

Example: [google api example html](https://gist.github.com/kozigh01/49a8c9313203d1aa4955a35fac48f2dd#file-z-implicit-flow-example-html) is a simple HTML page example of this flow \(can use this [simple node server code](https://gist.github.com/kozigh01/49a8c9313203d1aa4955a35fac48f2dd#file-z-static-node-server-md) to serve page\)

* After authenticating, open dev tools and inspect GoogleAuth.currentUser.Ab.Zi in the console to see token

Main points:

* Application never gets user credentials, only the trusted third party does \(while authenticating\)
* For Android and iOS/Swift: [AppAuth](https://appauth.io/) - open source library to help with this flow, formally maintained by OpenID Foundation \(supported by Google and other big players\).  Uses mobile browsers secure cookie store - session support for single sign on experience.
* Single-page Apps: [Passport](http://www.passportjs.org/) \([blog post](https://medium.com/front-end-hacking/notes-passport-and-oauth-296325e27da), [Hidden Manual](https://github.com/jwalton/passport-api-docs)\) is an option.

Security Considerations:

* Access token is permission to act as the user - need to store and use it securely at all times.
* Must use secure communications
* Test your redirect\_uri whitelist
* All resource servers must validate the access tokens

### Authorization Code Flow \(Server Side\)

This flow is not for client side applications, should be used on the server side.

Main points:

* It's not simple, but is reliable
* It's not mobile friendly, but we can trust it
* Works the same in any back-end programming language
* The attack/threat vectors are small and short-lived
* Large and growing ecosystem including libraries, Postman, etc.
* Good because, the 3rd party application never gets credentials and the end user never gets access token

See [Okta Authorization Code Flow](https://developer.okta.com/authentication-guide/auth-overview/#authorization-code-flow) for diagram and [Implement the Authorization Code Flow](https://developer.okta.com/authentication-guide/implementing-authentication/auth-code) for details about implementing this flow in Okta. See [Implement the Authorization Code Flow](https://developer.okta.com/authentication-guide/implementing-authentication/auth-code) for details.

Creating the Authorization Code url is complex, so use a well-established library.

Postman Example: 

1.  Google OAuth app info: 
   1. Goto [Google - Obtaining OAuth 2.0 access tokens](https://developers.google.com/youtube/v3/guides/auth/server-side-web-apps#obtainingaccesstokens) - look for HTTP/REST in document \(or https://\) 1. Auth url: [https://accounts.google.com/o/oauth2/v2/auth](https://accounts.google.com/o/oauth2/v2/auth) 2. Access Token url: [https://www.googleapis.com/oauth2/v4/token](https://www.googleapis.com/oauth2/v4/token) 3. Scope: go to [Google - youtube auth guide](https://developers.google.com/youtube/v3/guides/auth/server-side-web-apps) and look for 'Identify access scopes', pick the readonly scope 2. Goto [Google API Console](https://console.developers.google.com/apis/dashboard?project=diesel-talon-203720&folder&organizationId&duration=PT1H) select 'Credentials' then click on a target OAuth client id \(or create one if needed\): 1. Client Id and Client Secret are listed \(DON'T share Client Secret!!\) 2. 'Callback url' must be added to the 'Authorized redirect URIs' white list 2. Create Postman request: 1. Create a 'GET' request 2. On 'Authorization' tab, select 'OAuth 2.0' 3. Click 'Get New Access Token': 1. Enter a token name: Youtube Token 2. Callbak URL: [https://www.getpostman.com/oauth2/callback](https://www.getpostman.com/oauth2/callback) \(must be whitelisted for google OAuth credential\) 3. Auth URL: [https://accounts.google.com/o/oauth2/v2/auth](https://accounts.google.com/o/oauth2/v2/auth) \(from step 1 above\) 4. Access Token URL: [https://www.googleapis.com/oauth2/v4/token](https://www.googleapis.com/oauth2/v4/token) \(from step 1 above\) 5. Client ID: enter client id from step 1 above 6. Client secret: enter client id from step 1 above 7. Scope: [https://www.googleapis.com/auth/youtube.readonly](https://www.googleapis.com/auth/youtube.readonly) 3. Run the Postman request - this should pop-up a google login dialogue. Login with Google credentials. Note that the 3rd party app \(Postman in the case\) does not have access to these credentials - this is all Google provided. 4. A postman dialogue showing the 'Access Token' should appear. Can look at token at [https://www.jsonwebtoken.io/](https://www.jsonwebtoken.io/). Not much useful info here.

Security Considerations:

* Protect the auth code - is a one-time code that can be used to get the access token.  Client \(browser\) never gets the actual access token.
* Be careful of active browser sessions. Generally, user-consent screens will mitigate this risk.
* Must use secure communications \(TLS\)
* Test your redirect\_uri whitelist. Confirm that your server doesn't accept any arbitrary redirect\_uri
* All resource servers must validate the access tokens.
* Impersonation problem.  May 2017 "Google Docs Worm" - disguised itself as Google and asked for permissions via the normal OAuth authorization flow.  This was 100% human behaviour, not a flaw in OAuth.

## Resource Owner Password Flow \(For Legacy Situations\)

See Okta's [Resource Owner Password Flow](https://developer.okta.com/authentication-guide/auth-overview/#resource-owner-password-flow) for description and diagram. See [Implementing the Resource Owner Password Flow](https://developer.okta.com/authentication-guide/implementing-authentication/password) for details.

Note that this flow is considered fundamentally more risky by many, because the 3rd party application is getting the user's password \(even though the user never gets the access token\) - this defeats many of the benefits of OAuth. This often used on legacy apps 'to get started with OAuth' - as such this should be a temporary solution, only used until a better flow can be implemented. **There is no reason to use this on a new application**.

Security Considerations:

* Protect the client\_secret \(for backend apps only\)
* Must use secure communications like TLS
* Protect access token \(use and storage\)
* Validate the access token
* **User is giving credentials to the application**.  So the application developer\(s\) has your credentials.  Can't revoke access - must change password.

